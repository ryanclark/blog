<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <title>RGB to Hex via Binary Shifting</title>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />
<link href="/css/main.7e17a2d15e29622d96390305914074ff.css" rel="stylesheet"></head>
<body>

<aside class="sidebar">
  <div class="sidebar__fixed">
    <div class="sidebar__info">
      
      <a href="/" class="logo">
        <canvas width="72px" height="72px"></canvas>
      </a>
      

      <div class="sidebar__overlay ">
        <span class="sidebar__title">ryanclark.me</span>

        <ul class="social">
          <li class="social__item">
            <a target="_blank" href="https://twitter.com/rynclark">
              <i class="fa fa-fw fa-twitter"></i>
            </a>
          </li>
          <li class="social__item">
            <a target="_blank" href="/feed.xml">
              <i class="fa fa-fw fa-rss"></i>
            </a>
          </li>
          <li class="social__item">
            <a target="_blank" href="http://github.com/rynclark">
              <i class="fa fa-fw fa-github"></i>
            </a>
          </li>
        </ul>
      </div>
    </div>

    <nav class="navigation">
      <ul class="navigation__list">
        <li class="navigation__item">
          <h3 class="navigation__header">React</h3>
        </li>
        <li class="navigation__item">
          <a href="/going-native-with-react/" class="navigation__link">
            Go native with React
          </a>
        </li>
        <li class="navigation__item">
          <a href="/getting-started-with-flux/" class="navigation__link">
            Introduction to Flux
          </a>
        </li>
        <li class="navigation__item">
          <a href="/getting-started-with-react/" class="navigation__link">
            Getting started with React
          </a>
        </li>
      </ul>
      <ul class="navigation__list">
        <li class="navigation__item">
          <h3 class="navigation__header">Angular</h3>
        </li>
        <li class="navigation__item">
          <h4 class="navigation__sub-header">1.x</h4>
        </li>
        <li class="navigation__item">
          <a href="/how-angularjs-implements-dirty-checking/" class="navigation__link">
            How Angular dirty checks
          </a>
        </li>
      </ul>
      <ul class="navigation__list">
        <li class="navigation__item">
          <h3 class="navigation__header">Misc</h3>
        </li>
        <li class="navigation__item">
          <a href="/rgb-to-hex-via-binary-shifting/" class="navigation__link">
            RGB to hex via binary shifting
          </a>
        </li>
      </ul>
    </nav>

    <div class="sidebar__progress">
      <div class="sidebar__progress__bar"></div>
    </div>
  </div>
</aside>


<section class="content">
  <div class="container">
    <article class="article">
	<header>
		<h2>RGB to Hex via Binary Shifting</h2>
		<span class="time">16 Apr 2015</span>
	</header>

  <div class="post contents">



	  <p>A colleague of mine presented me with this code, baffled as to how it works<!--more--> -</p>

<div class="code-block">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="language-js" data-lang="js">1
2
3</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">rgbToHex</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nx">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nx">b</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

</div>

<p>We know it converts an RGB value to it’s hexadecimal equivalent, but how? It’s doing some crazy stuff with binary, but when broken down it’s actually incredibly simple and very clever.</p>

<h2 id="hex-codes">Hex Codes</h2>

<p>Hex codes are six characters long, the first two being red, middle two being green and the last two being blue. Each character is a hexadecimal number.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>R</th>
      <th>R</th>
      <th>G</th>
      <th>G</th>
      <th>B</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>#</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<h4 id="hexadecimal-numbers">Hexadecimal Numbers</h4>

<p>A hex value can go from <code>0</code> to <code>F</code> - a maximum of 16 different values. When putting two together, we can now have a maximum of 256 (16 multiplied by 16) values (<code>0</code> through to <code>255</code>). We can represent <code>0</code> through to <code>255</code> in 8 bits.</p>

<p><em>0 represented in 8 bits</em></p>

<table>
  <thead>
    <tr>
      <th>128</th>
      <th>64</th>
      <th>32</th>
      <th>16</th>
      <th>8</th>
      <th>4</th>
      <th>2</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p><em>256 represented in 8 bits</em></p>

<table>
  <thead>
    <tr>
      <th>128</th>
      <th>64</th>
      <th>32</th>
      <th>16</th>
      <th>8</th>
      <th>4</th>
      <th>2</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>This means that red, green and blue can have 256 different variations each - that’s 16,581,375 colours we can reference in just 6 characters!</p>

<h2 id="double-arrow">Double Arrow?</h2>

<p>If you don’t know about bitwise operators, you might be very confused to see a <code>&lt;&lt;</code> in JavaScript. Don’t worry, what it does is very easy to understand.</p>

<p>The <code>&lt;&lt;</code> operator is also known as a left shift. This will shift the value of <code>r</code> 16 bits to the left. You can, at a maximum, shift a number 31 bits to the left.</p>

<h4 id="lets-do-an-example">Let’s do an example</h4>

<p>The number one, represented as a decimal, is <code>1</code>. Represented as binary (in 17 bits for the sake of consistency), is -</p>

<table>
  <thead>
    <tr>
      <th>65536</th>
      <th>32768</th>
      <th>16384</th>
      <th>8192</th>
      <th>4096</th>
      <th>2048</th>
      <th>1024</th>
      <th>512</th>
      <th>256</th>
      <th>128</th>
      <th>64</th>
      <th>32</th>
      <th>16</th>
      <th>8</th>
      <th>4</th>
      <th>2</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>When we shift <code>1</code> 16 bits to the left, we’re adding 16 <code>0</code>’s to the right of the one.</p>

<table>
  <thead>
    <tr>
      <th>65536</th>
      <th>32768</th>
      <th>16384</th>
      <th>8192</th>
      <th>4096</th>
      <th>2048</th>
      <th>1024</th>
      <th>512</th>
      <th>256</th>
      <th>128</th>
      <th>64</th>
      <th>32</th>
      <th>16</th>
      <th>8</th>
      <th>4</th>
      <th>2</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Which as a decimal, is equal to <code>65536</code>.</p>

<p>That’s all it does! Told you it was simple.</p>

<h2 id="breaking-it-down">Breaking it down</h2>

<p>We’re going to start with the middle section - the part that deals with converting the red value to hexadecimal.</p>

<h4 id="red">Red</h4>

<p>The code that does this is <code>(r &lt;&lt; 16)</code>. The red value is always first in a hex code, so in order to make room for green and blue, we shift it 16 bits to the left. This gives us the red value in binary, as well as 16 bits on the end - 8 bits for green and 8 bits for blue.</p>

<p>If we do <code>(255 &lt;&lt; 16)</code>, we get the binary</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Which, when converted to hexadecimal, is equal to <span style="width: 10px; height: 10px; display: inline-block; background: #ff0000"></span> <code>ff0000</code>.</p>

<h4 id="green">Green</h4>

<p>Now that we have converted red to binary and left room for green and blue, we can shift the green value 8 bits to the left. The code that does this is <code>(g &lt;&lt; 8)</code>.</p>

<p>If we shift 255 to the left by 8 bits and represent it in 24 bits, we get this -</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Which, as hexadecimal, is equal to <span style="width: 10px; height: 10px; display: inline-block; background: #00ff00"></span> <code>00ff00</code>.</p>

<p>If you compare that table and the table in the red section, you can see that they line up perfectly - we can add the two values together without them conflicting.</p>

<p><em>Take the red value</em></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><em>add the green value</em></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><em>and we get</em></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>When this is converted to hexadecimal, it is <span style="width: 10px; height: 10px; display: inline-block; background: #ffff00"></span> <code>ffff00</code> - the correct representation of <code>rgb(255, 255, 0)</code> as a hex.</p>

<h4 id="blue">Blue</h4>

<p>We don’t need to shift our blue value to the left, because we are taking up the last 8 bits with it. If you look at the original code, you can see it just does <code>+ b</code> at the end. This is because when adding a binary number and a decimal number in JavaScript, the decimal will be converted over to binary before it’s added.</p>

<p>If our blue value is 255, the binary representation of it is (again, in 24 bits)</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Which, when added to our red and green value, outputs</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Which is equal to “ffffff” when converted to a hexadecimal! Most of you will know that this colour is in fact white, or <code>rgb(255, 255, 255)</code>.</p>

<h4 id="padding">Padding</h4>

<p>Wait a minute - what’s that <code>(1 &lt;&lt; 24)</code> at the start? Why is it needed?</p>

<p>The decimal number <code>1</code> shifted 24 bits to the left provides us with the necessary padding for our RGB values in binary. When you convert a decimal number to a binary number, you aren’t guaranteed 8 bits back - you will get the amount of bits it takes to represent that number (the reason we got 8 bits back for our 255 values is because it takes 8 bits to represent 255 in binary) - if you convert decimal <code>0</code> to binary you will only get one bit back - <code>0</code>, or if you convert 13 to binary you will get four bits back - <code>1101</code>.</p>

<p>When we shift 1 to the left 24 bits, we get this -</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>The number 1 followed by 24 bits - 8 bits for each of our colour values.</p>

<p>This means that whenever we add the results from converting our RGB values to binary, regardless of how many bits the result is, it’ll always add into the correct section of bits because we are shifting the values to the left by either 16, 8 or 0 bits.</p>

<h2 id="binary-to-hexadecimal">Binary to Hexadecimal</h2>

<p>We can convert our binary number into a hexadecimal string by using <code>toString</code> and passing it <code>16</code> as a value. Alternatively, you can use <code>2</code> for binary or <code>8</code> for octal.</p>

<div class="code-block">

<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><code class="language-js" data-lang="js"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</code></pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">rgbToHex</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// r = 255, g = 255, b = 255</span>
    <span class="k">return</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span>
    <span class="p">(</span>
        <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
            <span class="c1">// Value: 16777216 or 1000000000000000000000000</span>
        <span class="o">+</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
            <span class="c1">// Value: 16711680 or 111111110000000000000000</span>
            <span class="c1">// Total: 33488896 or 1111111110000000000000000</span>
        <span class="o">+</span> <span class="p">(</span><span class="nx">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span>
            <span class="c1">// Value: 65280 or 1111111100000000</span>
            <span class="c1">// Total: 33554176 or 1111111111111111100000000</span>
        <span class="o">+</span> <span class="nx">b</span>
            <span class="c1">// Value: 255 or 11111111</span>
            <span class="c1">// Total: 33554431 or 1111111111111111111111111</span>
    <span class="p">)</span>
    <span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="c1">// &quot;1ffffff&quot;</span>
    <span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// &quot;ffffff&quot;</span>
<span class="p">}</span>

<span class="nx">rgbToHex</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">// #ffffff</span>
</pre></div>
</td></tr></table>

</div>

<h2 id="conclusion">Conclusion</h2>

<p>As you can see, the code used above is very clever but also very daunting to look at if you don’t understand what’s happening underneath the hood. Hopefully this post makes it all a lot clearer!</p>

<p>If you have any queries, feel free to contact me on Twitter via <a href="https://twitter.com/rynclark" target="_blank">@rynclark</a></p>

<p>Credit to the appropriate authors in this <a href="http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb" target="_blank">stackoverflow post.</a></p>

	</div>

  <span class="p">{</span>
  <span class="err">//</span>
  <span class="nt">&quot;flux&quot;</span>
  <span class="s2">&quot;2.0.1&quot;</span>
  <span class="nt">&quot;react&quot;</span>

	<div class="disqus">
		<div id="disqus_thread"></div>
	</div>
</article>

<script>
  var disqus_url = "http://ryanclark.me//rgb-to-hex-via-binary-shifting";
  var disqus_title = "RGB to Hex via Binary Shifting";
  var disqus_shortname = 'rynclark';
  (function() {
    var dsq = document.createElement('script');
    dsq.async = dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    document.getElementsByTagName('head')[0].appendChild(dsq);
  })();
</script>

<script>
  var c = document.querySelector('canvas');
  var ctx = c.getContext("2d");

  // SVG is resolution independent. Canvas is not. We need to make our canvas
  // High Resolution.

  // lets get the resolution of our device.
  var pixelRatio = window.devicePixelRatio || 1;

  // lets scale the canvas and change its CSS width/height to make it high res.
  c.style.width = c.width +'px';
  c.style.height = c.height +'px';
  c.width *= pixelRatio;
  c.height *= pixelRatio;

  // Now that its high res we need to compensate so our images can be drawn as
  //normal, by scaling everything up by the pixelRatio.
  ctx.setTransform(pixelRatio,0,0,pixelRatio,0,0);
  ctx.translate(-4, 0);

  var cw = c.width;
  var ch = c.height;

  function createClip(ctx) {
    ctx.save();
    ctx.miterLimit=4;
    ctx.scale(1.0973936899862824,1.0973936899862824);
    ctx.translate(0.17219917012447183,0);
    ctx.scale(1.0926694329183957,1.0926694329183957);
    ctx.restore();

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(33.2,31.5);
    ctx.bezierCurveTo(33.2,36.3,31.400000000000002,39.5,27.900000000000002,41);
    ctx.lineTo(32.900000000000006,59.9);
    ctx.bezierCurveTo(33.10000000000001,60.8,32.7,61.199999999999996,31.900000000000006,61.199999999999996);
    ctx.lineTo(24.400000000000006,61.199999999999996);
    ctx.bezierCurveTo(23.700000000000006,61.199999999999996,23.300000000000004,60.8,23.200000000000006,60.199999999999996);
    ctx.lineTo(18.400000000000006,41.89999999999999);
    ctx.lineTo(13.400000000000006,41.89999999999999);
    ctx.lineTo(13.400000000000006,60);
    ctx.bezierCurveTo(13.400000000000006,60.7,13.000000000000005,61.2,12.200000000000006,61.2);
    ctx.lineTo(4.8,61.2);
    ctx.bezierCurveTo(4.1,61.2,3.5999999999999996,60.800000000000004,3.5999999999999996,60);
    ctx.lineTo(3.5999999999999996,4.7);
    ctx.bezierCurveTo(3.6,4,4,3.6,4.8,3.6);
    ctx.lineTo(22.900000000000002,3.6);
    ctx.bezierCurveTo(29.700000000000003,3.6,33.300000000000004,7.2,33.300000000000004,14);
    ctx.lineTo(33.300000000000004,31.5);
    ctx.closePath();
    ctx.moveTo(20.5,32.4);
    ctx.bezierCurveTo(22.4,32.4,23.4,31.4,23.4,29.5);
    ctx.lineTo(23.4,16);
    ctx.bezierCurveTo(23.4,14.1,22.4,13.1,20.5,13.1);
    ctx.lineTo(13.4,13.1);
    ctx.lineTo(13.4,32.4);
    ctx.lineTo(20.5,32.4);
    ctx.moveTo(69.3,21.7);
    ctx.bezierCurveTo(69.3,22.4,68.89999999999999,22.9,68.1,22.9);
    ctx.lineTo(60.89999999999999,22.9);
    ctx.bezierCurveTo(60.099999999999994,22.9,59.69999999999999,22.5,59.69999999999999,21.7);
    ctx.lineTo(59.69999999999999,16);
    ctx.bezierCurveTo(59.69999999999999,14.1,58.69999999999999,13.1,56.79999999999999,13.1);
    ctx.lineTo(53.09999999999999,13.1);
    ctx.bezierCurveTo(51.19999999999999,13.1,50.19999999999999,14.1,50.19999999999999,16);
    ctx.lineTo(50.19999999999999,48.8);
    ctx.bezierCurveTo(50.19999999999999,50.699999999999996,51.19999999999999,51.699999999999996,53.09999999999999,51.699999999999996);
    ctx.lineTo(56.79999999999999,51.699999999999996);
    ctx.bezierCurveTo(58.69999999999999,51.699999999999996,59.69999999999999,50.8,59.69999999999999,48.8);
    ctx.lineTo(59.69999999999999,43);
    ctx.bezierCurveTo(59.69999999999999,42.3,60.09999999999999,41.8,60.89999999999999,41.8);
    ctx.lineTo(68.1,41.8);
    ctx.bezierCurveTo(68.8,41.8,69.3,42.199999999999996,69.3,43);
    ctx.lineTo(69.3,50.8);
    ctx.bezierCurveTo(69.3,57.599999999999994,65.6,61.199999999999996,58.9,61.199999999999996);
    ctx.lineTo(50.8,61.199999999999996);
    ctx.bezierCurveTo(44,61.199999999999996,40.4,57.599999999999994,40.4,50.8);
    ctx.lineTo(40.4,14);
    ctx.bezierCurveTo(40.4,7.2,44.1,3.5999999999999996,50.8,3.5999999999999996);
    ctx.lineTo(58.9,3.5999999999999996);
    ctx.bezierCurveTo(65.6,3.5999999999999996,69.3,7.199999999999999,69.3,14);
    ctx.lineTo(69.3,21.7);
    ctx.closePath();
    ctx.clip();
  }

  var points = [];
  var tick = 0;
  var opt = {
    count: 5,
    range: {
      x: 0,
      y: 7
    },
    duration: {
      min: 20,
      max: 100
    },
    thickness: 0,
    strokeColor: '#444',
    level: 1,
    curved: true
  };

  var post = document.querySelector('.contents');
  var bar = document.querySelector('.header__progress__bar');

  var documentSize = document.body.scrollHeight;
  var postHeight = post.getBoundingClientRect().top + post.getBoundingClientRect().height;

  var bodyRect = document.body.getBoundingClientRect(),
    elemRect = post.getBoundingClientRect(),
    offsets   = elemRect.top - bodyRect.top;

  var offset = c.height + 5;

  ctx.lineWidth = 0;
  var timeout;
  function changeWidth() {
    var scrollPercentage = 1 - ((window.scrollY) / (elemRect.height + offsets - window.innerHeight));
    offset = (72 * scrollPercentage) + 5;
    ctx.lineWidth = 16 * Math.max(0, (1 - scrollPercentage) - 0.3);

    opt.range.y = 10;
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      opt.range.y = 2;
    }, 1000);
  }

  window.addEventListener('scroll', changeWidth);
  window.addEventListener('resize', changeWidth);

  function rand(min, max){
    return Math.floor( (Math.random() * (max - min + 1) ) + min);
  }

  function ease(t, b, c, d) {
    if ((t/=d/2) < 1) return c/2*t*t + b;
    return -c/2 * ((--t)*(t-2) - 1) + b;
  }

  ctx.lineJoin = 'round';

  var Point = function(config){
    this.anchorX = config.x;
    this.anchorY = config.y;
    this.x = config.x;
    this.y = config.y;
    this.setTarget();
  };

  Point.prototype.setTarget = function(){
    this.initialX = this.x;
    this.initialY = this.y;
    this.targetX = this.anchorX + rand(0, opt.range.x * 2) - opt.range.x;
    this.targetY = this.anchorY + rand(0, opt.range.y * 2) - opt.range.y;
    this.tick = 0;
    this.duration = rand(opt.duration.min, opt.duration.max);
  }

  Point.prototype.update = function(){
    var dx = this.targetX - this.x;
    var dy = this.targetY - this.y;
    var dist = Math.sqrt(dx * dx + dy * dy);

    if(Math.abs(dist) <= 0){
      this.setTarget();
    } else {
      var t = this.tick;
      var b = this.initialY;
      var c = this.targetY - this.initialY;
      var d = this.duration;
      this.y = ease(t, b, c, d);

      b = this.initialX;
      c = this.targetX - this.initialX;
      d = this.duration;
      this.x = ease(t, b, c, d);

      this.tick++;
    }
  };

  Point.prototype.render = function(){
    ctx.beginPath();
    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
    ctx.fillStyle = '#000';
    ctx.fill();
  };

  var updatePoints = function(){
    var i = points.length;
    while(i--){
      points[i].update();
    }
  };

  var renderPoints = function(){
    var i = points.length;
    while(i--){
      points[i].render();
    }
  };

  var lotsOfPoints = [];

  function quadraticBezierCurvePoint(t, c) {
    // compute relative coordinates of a point on the curve using t and c
    // t is a number between 0 and 1
    // c is an array of 3 points:
    //     the initial point of the curve (always (0,0))
    //     the "handle" point of the curve
    //     the final point of the curve
    var t1, t1_2a, t1_2b, t1_2c;
    t1 = 1 - t;
    t1_2a = t1 * t1;
    t1_2b = (2 * t) * t1;
    t1_2c = t * t;
    return {
      x: (c[0].x * t1_2a) + (t1_2b * c[1].x) + (t1_2c * c[2].x),
      y: (c[0].y * t1_2a) + (t1_2b * c[1].y) + (t1_2c * c[2].y)
    };
  }
  function b2p0(t, p) {
    var k = 1 - t;
    return k * k * p;
  }

  function b2p1(t, p) {
    return 2 * (1 - t) * t * p;
  }

  function b2p2(t, p) {
    return t * t * p;
  }

  function b2(t, p0, p1, p2) {
    return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );
  }

  function tangentQuadraticBezier(p0, p1, p2, t) {
    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
  }
var log = false;
  var renderShape = function(){
    lotsOfPoints = [];
    ctx.beginPath();
    var pointCount = points.length;
    ctx.moveTo(points[0].x, points[0].y + offset);
    var i;
    for (i = 0; i < pointCount - 1; i++) {
      var c = (points[i].x + points[i + 1].x) / 2;
      var d = (points[i].y + points[i + 1].y) / 2;
      ctx.quadraticCurveTo(points[i].x, points[i].y + offset, c, d + offset);
    }
    ctx.lineTo(-opt.range.x - opt.thickness, ch + opt.thickness + offset);
    ctx.lineTo(cw + opt.range.x + opt.thickness, ch + opt.thickness + offset);
    ctx.closePath();
    ctx.fillStyle = pattern2;
    ctx.fill();
    ctx.strokeStyle = pattern;
    ctx.stroke();

    ctx.save();

    for (var i = 0; i < bubbles.length; i++) {
      bubbles[i].ycoord -= bubbles[i].move;
      if (bubbles[i].ycoord < (offset + 16)) {
        bubbles[i].xcoord = getRandomNum(0, cw);
        bubbles[i].ycoord = ch + maxRadius;
        bubbles[i].radius = getRandomNum(minRadius, maxRadius);
        bubbles[i].move = getRandomNum(minMove, maxMove);
      }

      ctx.beginPath();
      ctx.arc(bubbles[i].xcoord, bubbles[i].ycoord, bubbles[i].radius, 0, Math.PI*2, false);
      ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
      ctx.fill();
      ctx.closePath();
    }
  };


  /**
   *  Get Random Integer
   */
  function getRandomInt (min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   *  Get Random Number
   */
  function getRandomNum(min, max) {
    return (Math.random() * (max - min + 1)) + min;
  }

  var bubbles = new Array();
  var bubblesNum = 75;

  var minRadius = 1;
  var maxRadius = 3;
  var minMove = 0.1;
  var maxMove = 0.2;

  for (var i = 0; i < bubblesNum; i++) {
    bubbles[i] = {
      xcoord: getRandomNum(0, cw),
      ycoord: getRandomNum(0, ch),
      radius: getRandomNum(minRadius, maxRadius),
      move: getRandomNum(minMove, maxMove)
    }
  }

  var clear = function(){
    ctx.clearRect(0, 0, cw, ch);
  };

  var i = opt.count + 2;
  var spacing = (cw + (opt.range.x * 2)) / (opt.count-1);
  while(i--){
    points.push(new Point({
      x: (spacing * (i - 1)) - opt.range.x,
      y: ch - (ch * opt.level)
    }));
  }


  window.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(a){window.setTimeout(a,1E3/60)}}();

  var loop = function(){
    window.requestAnimFrame(loop, c);
    tick++;
    clear();
    createClip(ctx);
    ctx.fillStyle = "#262626";
    ctx.fillRect(0, 0, cw, ch);

    updatePoints();
    renderShape();
  };
  var tempCanvas = document.createElement("canvas"),
    tCtx = tempCanvas.getContext("2d");

  var tempCanvas2 = document.createElement("canvas"),
    tCtx2 = tempCanvas2.getContext("2d");

  var pattern, pattern2;

  var img1 = new Image();
  //drawing of the test image - img1
  img1.onload = function () {
    tempCanvas.width = cw;
    tempCanvas.height = 16;
    tCtx.drawImage(img1, 0, 0, cw, 16, 0, 0, cw, 16);
    pattern = ctx.createPattern(tempCanvas, 'repeat');

    tempCanvas2.width = cw;
    tempCanvas2.height = ch;
    tCtx2.drawImage(img1, 0, 0, img1.width, img1.height, 0, -100, cw, ch + 100);
    pattern2 = ctx.createPattern(tempCanvas2, 'repeat');
    loop();
  };

  img1.src = 'http://static6.bigstockphoto.com/thumbs/1/5/9/small2/95113916.jpg';
</script>


    <div class="main-background">
      <div class="main-background__left">
        <div class="main-background__overlay"></div>
      </div>
      <div class="main-background__right">
        <div class="main-background__overlay"></div>
      </div>
    </div>
  </div>
</section>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49723822-1', 'auto');
  ga('send', 'pageview');
</script>

<script type="text/javascript" src="/js/main.335918d038e996e66abe.js"></script></body>
</html>
